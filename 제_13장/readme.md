# 명령어 세트 : 주소 지정 방식과 형식


## 주소 지정 방식(Addressing Mode)

1. `즉시(Immediate)`
    - 명령어가 operand 포함
2. `직접(Direct)`
    - 명령어 주소 = operand 위치
3. `간접(Indirect)`
    - 명령어 주소 = operand 위치를 가르키는 주소
4. `레지스터(Registor)`
    - 명령어의 주소 = 레지스터 번호
5. `레지스터 간접(Registor Indirect)`
    - 명령어의 주소 -> 레지스터 번호 -> operand 주소
6. `변위(Displacement)`
    - 여러 개의 주소 결합(덧셈)을 통한 상대주소 계산
7. `스택(Stack)`
    - CPU가 지정하는 자동 증가 주소(암묵적임)

<br/>

### 주소 지정 방식들

<img height="80%" width="80%" src="https://github.com/ash9river/Computer-Organization-and-Architecture/assets/121378532/aeb6eaf4-523b-47dc-a19c-7183970bb3e1">

<br/>

### 기본적인 주소지정 방식들

<img height="80%" width="80%" src="https://github.com/ash9river/Computer-Organization-and-Architecture/assets/121378532/c9dbd9d7-a54e-4239-abc9-d7cb1c4803a7">

<br/>
<br/>

## 즉시 주소지정

- 가장 간단한 형태의 **주소** 지정
- 오퍼랜드 = A (주소필드)
- 이 방식은 `상수(constant)`를 정의하여 사용하거나, 변수의 초기 값을 세트하는데 사용한다.
  - 일반적으로 수는 **2의 보수 형태**로 저장한다.
  - 오퍼랜드 필드의 맨 좌측 비트(MSB)가 부호 비트로 사용된다.
- 장점
  - 오퍼랜드를 인출하거나 기억장치를 참조할 필요가 없어서, **명령어 사이클**에서 하나의 기억장치 사이클 또는 캐시 사이클을 줄일 수 있다.
- 단점
  - 수의 크기가 주소필드의 크기로 제한된다.
 
> $Instruction(word) = opcode + Address \ Field$

<br/>

## 즉시 주소 지정

- 명령어의 주소 필드가 오퍼랜드의 유효주소(EA)를 가지고 있다.
- $EA = A$
  - $EA = operand$
- 초기의 컴퓨터들에게 널리 사용되었다.
- 한번의 기억장치 참조만 필요하며, 다른 특별한 계산은 필요 없다.
- 주소 공간이 제한되어 있다.

<br/>

## 간접 주소 지정

- 주소 필드는 기억장치에 저장된 단어의 주소를 가리키도록 하고, 그 기억장치에 오퍼랜드의 주소 전체가 저장되어 있도록 하는 방식
- $EA = (A)$
  - 괄호는 그 내용을 의미하는 것으로 해석
- 장점
  - 단어 길이가 N이면, $2^{n}$ 개의 주소 공간을 가질 수 있다.
- 단점
  - 명령어 실행 과정에서 두 번의 기억장치 참조들이 필요하다.
  - 두 번째는 그 주소가 지정하는 위치로부터 오퍼랜드를 가져오기 위한 것이다.
- 간접 주소 지정의 변형으로 다단계(multilevel) 또는 연속(cascaded) 간접 주소 지정 방식
  - $EA = (...(A)...)$
  - 단점은 한 개의 오퍼랜드를 인출하기 위해서 여러 번의 기억장치 참조들이 필요하다.
 
## 레지스터 주소 지정

- 주소 필드가 주 기억장치 주소가 아닌 레지스터(번호)를 가리킨다.
- $EA = R$
  - $operand -> registor$
- 장점
  - 명령어에서 주소 필드가 작아도 된다.
  - 기억장치 액세스가 필요없다.
- 단점
  - 주소 공간이 매우 제한된다.
> 만약 CPU 내의 Registor 수가 적다면, <br/>
> 장점은 번호에 사용되는 비트 수가 줄어든다. <br/>
> 단점은 공간이 작아진다.

<br/>

## 레지스터 간접 주소 지정

- 간접 주소 지정과 유사하나, 주소 필드가 기억장치와 레지스터 중에서 어느 것을 지정하냐가 다르다.
- $EA =(R)$
- 주소 필드에 의해 주소 공간이 제한되는 문제점은 그 필드가 주소를 가지고 있는 단어의 위치를 가르킴으로써, 해결한다.
- 간접 주소 지정 방식보다 기억장치 액세스 횟수가 한 번 더 작다.

> Memory Access 횟수 단축 <br/>
> Address Space ⬆ = word size

<br/>

## 변위 주소 지정

- 직접 주소 지정과 레지스터 간접 주소 지정의 기능들을 조합
- $EA = A + (R)$
- 변위 주소 지정을 사용하는 명령어는 **두 개의 주소필드**들을 가지며, 그들 중에서 적어도 한 필드는 실제로 명시(explicit)된다.
  - $A + (R)$ : 명시 or 묵시 = 전용 레지스터
  - 하나의 주소 필드에 포함되어있는 값(A)는 직접 사용한다.
  - 다른 주소 필드 또는 연산 코드에 따른 묵시적 참조는 레지스터를 지정하며, 그 레지스터의 내용이 A와 더해져서 유효 주소를 생성한다.
- 가장 널리 사용되고 있는 세 가지 변위 주소 지정 방식들
  1. `상대 주소 지정(Relative Addressing)`
  2. `베이스-레지스터 주소 지정(Base-Registor Addressing)`
  3. `인덱싱(Indexing)`

<br/>

## 상대 주소 지정


















