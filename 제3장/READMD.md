![image](https://github.com/ash9river/Computer-Organization-and-Architecture/assets/121378532/73695b10-7efe-4595-b82b-669c5959ab85)# 제 3장 최상위에서 본 컴퓨터의 기능 및 상호연결

## 컴퓨터의 구성요소들

- 거의 모든 현대 컴퓨터의 설계는 폰 노이만 구조를 바탕으로 두고 있다.
  - 데이터와 명령어는 읽기와 쓰기가 가능한 기억장치에 함께 저장된다.
  - 기억장치의 내용은 저장된 데이터의 형식에 관계없이 위치에 따라 주소를 지정할 수 있다.
  - 명령어의 실행은 한 개씩 순서대로 진행된다.
- `하드와이어 프로그램(hardwired program)`
  - 여러 부품들을 모아서 필요한 기능을 수행하도록 연결하는 과정
- `소프트웨어`
  - 하드웨어(범용)의 한 부분이 각 명령어를 해석하여 제어신호를 발생
  - 하드웨어를 재구성하는 대신에 새로운 코드들을 제공 
- 하드웨어 vs 소프트웨어
  - 하드웨어에 프로그래밍하면 프로그래밍이 고정된다.
  - 소프트웨어에 프로그래밍하면 프로그래밍을 가변할 수 있다.

### 주요 구성요소들

- CPU
  - 명령어 해석기
  - 일반 목적용 산술 및 논리 기능 모듈
- I/O 모듈
  - `입력 모듈`
    - 임의 형태를 가진 데이터와 명령어들을 받아들이고 시스템에서 사용할 수 있는 내부 신호로 변환해주는 기본요소 포함
  - `출력 모듈`
    - 결과를 보고하는 수단
- Memory   
  - `기억장치 주소 레지스터(MAR)`
    - 다음에 읽거나 쓸 기억 장소의 주소를 지정
  - `기억장치 버퍼 레지스터(MBR)`
    - 기억장치에 저장될 데이터 혹은 기억장치로부터 읽은 데이터를 일시 저장
  - `I/O 주소 레지스터(I/OAR)`
    - 특정 I/O장치를 지정
  - `I/O 버퍼 레지스터(I/OBR)`
    - I/O 모듈과 CPU 사이의 데이터 교환을 위해 사용

<br/>
<br/>

## 기본 명령어 사이클(intstruction cycle)

                  loop
          ↙⬅⬅⬅⬅⬅⬅⬅⬅⬅⬅⬅⬅⬅↖
start->Fetch Next Instruction->Execute Instruction->Halt

<br/>

## 인출 사이클(Fetch Cycle)

- 각 명령어 사이클의 시작 단계에서 프로세서는 기억장치로부터 명령어를 인출한다.
- 프로그램 카운터(PC)는 다음에 인출할 명령어의 주소를 가지고 있다.
- 프로세서는 명령어를 인출한 다음에 PC의 내용을 증가시킴으로써 순서대로 다음 명령어를 인출한다.
- 인출된 명령어는 명령어 레지스터(IR)라고 불리는 프로세서 내부 레지스터에 적재된다.
- 프로세서는 명령어를 해석하고 그 결과에 따라 필요한 동작을 수행한다.

<br/>

### 동작 분류

1. `프로세서-기억장치`
  - 데이터는 프로세서에서 기억장치 or 기억장치에서 프로세서로 전송된다.
2. `프로세서-I/O`
  - 프로세서와 I/O 모듈 사이에 데이터를 전송함으로써 외부로 혹은 외부로부터 데이터가 전송된다.
3. `데이터 처리`
  - 프로세서는 데이터를 가지고 어떤 산술적 혹은 논리적 연산을 수행한다.
4. `제어`
  - 어떤 명령어는 실행 순서를 변경시키기도 한다.
  - 제어 이후 1번으로 루프

<br/>
<br/>

## 가상 머신의 특징

- 명령어 포맷
  - 4비트의 Opcode와 12비트의 주소로 총 16비트
- 인티저 포맷
  - 1비트의 부호비트와 15비트의 크기로 총 16비트
- CPU 내부 레지스터
  - `프로그램 카운터(PC)`: 다음에 인출될 명령어의 주소를 가지고 있는 레지스터
  - `명령 레지스터(IR)`: 가장 최근에 인출된 명령어가 저장되어 있는 레지스터.
  - `누산기(AC)`: 데이터를 일시적으로 저장하는 레지스터

### 프로그램 실행 예제

- 비표준 opcode
  - 0001 = Load AC from Memory
  - 0010 = Store AC to Memory
  - 0101 = Add to AC from Memory 
- 메모리에 있는건 Hexa 코드, 첫 숫자는 opcode, 나머지는 address

<details>
  <summary>Flow 따라서 천천히 </summary>

- Step 1 (Fetch Cycle)
  - 300 번지의 1940 IR에 저장
  - 1940 = 0001/940 -> Load AC from Memory(940)
    
|주소|메모리|여백|Internal CPU Registor|CPU Registor|
|:---|:---|---|---:|---:|
|300|1940||PC|300|
|301|5941||AC|x|
|302|2941|||IR|1940|
|940|0003||||
|941|0002||||

- Step 2 (Execute Cycle)
  - IR에 저장된 명렁어 실행 후 PC 증가시킴
  - AC에 0003 저장, PC 300 -> 301

|주소|메모리|여백|Internal CPU Registor|CPU Registor|
|:---|:---|---|---:|---:|
|300|1940||PC|301|
|301|5941||AC|0003|
|302|2941|||IR|1940|
|940|0003||||
|941|0002||||

- Step 3 (Fetch Cycle)
  - IR에 301 번지 명령어 5941 저장 

|주소|메모리|여백|Internal CPU Registor|CPU Registor|
|:---|:---|---|---:|---:|
|300|1940||PC|301|
|301|5941||AC|0003|
|302|2941|||IR|5941|
|940|0003||||
|941|0002||||

- Step 4 (Execute Cycle)
  - 5941 = 1010/941 -> Add AC from Memory(2)
  - 3 + 2 실행 후 PC 증가
    
|주소|메모리|여백|Internal CPU Registor|CPU Registor|
|:---|:---|---|---:|---:|
|300|1940||PC|302|
|301|5941||AC|0005|
|302|2941|||IR|5941|
|940|0003||||
|941|0002||||

- Step 5 (Fetch Cycle)
  - 302 번지 명령어 IR에 저장
  
|주소|메모리|여백|Internal CPU Registor|CPU Registor|
|:---|:---|---|---:|---:|
|300|1940||PC|302|
|301|5941||AC|0005|
|302|2941|||IR|2941|
|940|0003||||
|941|0002||||

- Step 6 (Execute Cycle)
  - 2941 = 0010/941 -> Storre AC to Memory
  - AC에 있는 값 메모리에 저장 후 PC 증가

 |주소|메모리|여백|Internal CPU Registor|CPU Registor|
|:---|:---|---|---:|---:|
|300|1940||PC|303|
|301|5941||AC|0005|
|302|2941|||IR|2941|
|940|0003||||
|941|0005||||

</details>
