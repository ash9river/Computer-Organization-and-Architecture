# 제 2장 성능 문제

## 성능을 위한 설계

- 해마다 가격은 하락하는데 성능과 용량이 크게 상승함.
- 각종 비즈니스들은 트랜잭션 및 데이터베이스의 처리를 대규모 클라이언트-서버 네트워크들을 지원하느 강력한 서버에 의존.
- 클라우드 서비스 제공 회사들은 대규모의 고성능 서버 뱅크들을 이용.

<br/>
<br/>

## 마이크로프로세서의 속도

- `파이프라이닝`:
  - 여러 개의 명령어들을 동시에 서로 다른 단계를 수행함으로써 다수의 명령어를 동시에 실행.
- `분기 예측`:
  - 프로세서는 기억장치로부터 인출된 명령어 코드를 미리 살펴보고, 어떤 분기 혹은 명령어가 다음에 처리될 것인지 미리 예측.
- `슈퍼스칼라 실행`:
  - 매 프로세서 클록 사이클마다 한 개 이상의 명령어 발송하는 능력. 결과적으로 여러 파이프라인들이 사용됨.
- `데이터 흐름 분석`:
  - 프로세서는 명령어들 간의 결과값 혹은 데이터에 대한 의존성을 분석함으로써 명령어들의 최적 실행 스케쥴을 찾아낸다.
- `추정 실행`:
  - 분기 예측과 데이터 흐름 분석을 이용하는 어떤 프로세서들은 명령어들이 프로그램 실행 과정에서 나타나기 전에 미리 명령어 실행, 이 때 결과값은 임시 장소에 저장됨.

<br/>
<br/>

## 성능 균형

- 다양한 구성 요소들의 능력 간의 불일치를 보완하기 위해서 조직과 구조(Organization & Architecture)를 적절히 조절하고 튜닝함.

<br/>

### 칩 조직과 구조의 개선

- 프로세서의 하드웨어 속도를 증가시킨다.
  - 근본적으로 프로세서 칩 상의 논리 게이트의 크기를 줄임.
  - 더 많은 게이트를 조밈랗게 넣고 클록 속도를 높인다.
  - 게이트들이 더 밀도 높게 위치하면 신호들의 전파 시간이 크게 줄어든다.
- 캐시의 크기와 속도를 증가시킨다.
  - 캐시 액세스 시간이 크게 줄어든다.
- 프로세서 조직과 구조를 바꾼다.
  - 병렬성을 이용하여 명령어 실행 속도를 높인다. 

<br/>

## 클록 속도와 회로 밀도가 증가함에 따른 문제점들

- `전력`:
  - 칩 내부 회로의 밀도와 클록 속도가 높아짐에 따라, 전력 밀도 또한 높아지고, 열 발산이 많아짐.
- `RC 지연`:
  - 칩 상에서 트랜지스터들 간에 흐르는 전자들의 속도는 금속선들의 저항과 캐퍼시턴스에 의해 제한.
  - RC 곱의 값이 증가함에 따라 지연도 길어짐.
  - 칩 상의 부품 크기가 작아질수록 연결선들은 더 가늘어져서 저항이 증가함.
  - 선들이 더 가까이 위치하면 캐퍼시턴스 증가.
- `기억장치 지연`:
  - 기억장치 액세스 속도는 프로세서 속도보다 뒤떨어진다.
 
<br/>
<br/>

## 멀티코어(Multicore)

- 동일 칩 상에 다수의 프로세서들를 두는 방식은 클록 속도를 높이지 않더라도 성능을 향상시키는 가능성을 제공한다.
- 하나의 복잡한 프로세서를 사용하는 것보다는 더 간단하게 여러 개의 프로세서들을 사용하는 것이다.

<br/>
<br/>

## 다수 집적 코어(MIC)와 그래픽 처리 유닛(GPU)

- `다수 집적 코어(MIC)`:
  - 성능 개선을 위하여 많은 수의 코어들을 이용하기 위한 소프트위어 개발에 대한 도전
  - 멀티코어 및 MIC 전략은 단일 칩에 범용 프로세서들을 모아두는 것을 포함
  - 병렬 프로세싱의 코딩
- `그래픽 처리 유닛(GPU)`:
  - 그래픽 데이터들에 대한 병령 연산을 수행하기 위하여 설계된 코아
  - CPU와 달리 연산장치가 많고 제어가 단순하다.

<br/>
<br/>

## 암달의 법칙

- 단일 프로세서에 비교하여 다수의 프로세서들을 사용한 프로그램의 잠재적 속도 향상에 대한 이론
<br/>

- $T$ : 단일 코어 속도 처리 진행시간(single core execute time)
- $f$ : 병렬 처리가 가능한 비율(percentage of parallel processing available)
- $N$ : 멀티코어 개수

$$T=(1-f)T+fT$$

#### 멀티코어 실행 시간(multi core execute time)

$$\frac{(1-f)T+fT}{N}=(1-f(\frac{1}{N}))T$$

#### 속도 향상

$$\frac{1}{1-f+\frac{f}{N}}$$

<br/>
<br/>

## 리틀의 법칙

- 통계적으로 안정된 상태와 누출이 없는 시스템에 적용.
- `큐잉 시스템(Queueing System)`:
  - 만약 서버가 쉬는 상태라면 개체는 즉시 서비스를 받음. 그렇지 않다면 도착한 개체는 대기열 혹은 큐에 들어간다.
  - 단일 서버를 위한 단일 큐(single queue) 혹은 다수 서버들를 위한 단일큐, 다수 큐 등등 시스템 구성은 다양하다.

>💡 안정 상태 조건 하에 큐잉 시스템 내에 있는 평균 개체 수는 개체들의 평균 도착율과 한 개체가 시스템에서 소모하는 평균 시간을 곱한 값과 같다. 

$L$ : 큐잉 시스템 내에 있는 평균 개체수<br/>
$\lambda$ : 개체들의 평균 도착률<br/>
$W$ : 한 개체가 시스템에서 소모하는 평균 시간<br/>

$$L=\lambda W$$

<br/>
<br/>

## 컴퓨터 성능의 동작

프로그램을 얼마나 빠르게 실행할 수 있을지를 알기 위해서 프로그램 실행시간 추정.
<br/>
 
- $CPI$ (Clock per time):
  - 단위(평균적인) 명령어당 평균 사이클(하나의 명령어를 처리하는데 몇 사이클이 걸리는지)
- $T$ (program execute time): 프로그램 실행 시간
- $MIPS rate$ (Millions of instructions per second) : 시간당 몇백만개의 명령어를 처리하는지
- `CPI 공식`
  
$$
  CPI=\frac{\displaystyle\sum_{i=1}^n(CPI_i \times I_i)}{I_c}
     =p+(m \times k)
$$

- 용어
  - $I_c$ (instruction count per time):
    - 프로그램당 명령어 수



- `프로그램 실행 시간 공식`

$$
  T=I_c \times CPI \times \tau =I_c \times [p+(m \times k)] \times \tau
$$

- 용어
  - $\tau$ : clock duration
  - $p$ : # of clock cycles for decoding/executing the instr
  - $m$ : # of memory reference
  - $k$ : memory cycle time/ processor cycle time
- CPU가 하나의 명령어를 처리하는데 걸리는 시간은 CPU가 하나의 명령어를 해석하는데에 걸리는 시간($p$)과 메모리를 접근하는데에 걸리는 시간($m$ $\times$ $k$)의 합과 같다.

- `MIPS rate`
  
$$
  MIPS=\frac{I_c}{T \times 10^6}=\frac{f}{CPI \times 10^6}
$$

- 용어
  - $f$ : clock frequency
 $$f=\frac{1}{\tau}$$
    
    
